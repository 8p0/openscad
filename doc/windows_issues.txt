This README covers a few caveats regarding OpenSCAD for Windows(TM) for
programmers and users.

Summary: As of writing, early 2014:

  -Windows filenames & cmdline args are ~UTF16, Linux/Mac are UTF8.
  -There is no open source ifstream/ofstream that works with UTF16 filenames
  -Therefore all file i/o must go through PlatformUtils:: wrappers
  -openscad.com is the command line wrapper for openscad.exe, the gui
  -Known bug - PRINTB output unicode to windows(TM) cmdline doesn't work

Unicode
=======

000. Non-Unicode encodings

Systems using encodings that are not based on unicode are not suported. 
For example running on an old Windows machine that, for some reason, is 
using KOI8 or SJIS instead of Unicode, is not supported currently and 
will have unknown results.

00. Encoding of Unicode

As you may know, Unicode can be encoded in many different ways. 
For the filesystem holding unicode filenames, an encoding of the
filenames themselves must be chosen. Unix(TM)/Mac(TM) use UTF8
Windows(TM) uses UTF16 (or UCS16 for very old versions). This 
means that the Windows Command Line Options and the Windows Filesystem 
will present UTF16 encoded filenames and commandline arguments to 
the program, as well as requiring UTF16 filenames from the 
program when performing certain tasks on those files. 

Unix/Mac typically use 'char' as the basic data type, and assume it is
an 8bit unsigned integer. Windows typically uses wchar_t instead, and
it's API functions are written with wchar_t in mind. 

Ideally there would be Open Source portable libraries that hid all 
these details, but as of writing (early 2014) there aren't any. There 
are many ways to deal with this, and numerous websites discuss the 
various alternative approaches. 

00. Windows(TM) unicode conventions

A large number of documents about programming with unicode on 
Windows(TM) will discuss things like tchars, _T macros, "Ansi" mode 
building vs 'Unicode' building, 'UNICODE' macros, functions that end 
with DeleteFileA vs DeleteFileW, etc etc. The OpenSCAD strategy (as of 
writing) is to avoid tchars completely, build only for 'Unicode mode', 
convert everything to UTF8 for processing internally, and only convert 
to UTF16 when we need to call Windows functions, all of which should be 
the 'w' version (_wfopen for example).

0. Program Startup, main(), Command Line arguments, and Unicode

Windows has multiple different 'entry points' for historical reasons, 
some of which are Windows compiler specific and some of which are 
designed to deal with unicode on Windows console programs, etc etc. 
There is WinMain, wmain, tmain, etc, some of which use special args like 
wchar_t wargv, etc. MingW-64 also contains a '-municode' flag and other 
fetaures to work with these concepts. None of this is necessary. 

We just use ordinary int main(int argc,char*argv), ignore argc and argv 
(which will be invalid for unicode args) then call GetCommandLineW(), 
which fetches the 'real' UTF16 command line from the Operating System. 
Then... we convert the command line to UTF8, and re-write argv so it 
points to UTF8 encoded strings, and then proceed as normal.

Note that QT (our GUI toolkit) itself also reads from GetCommandLineW()
on QApplication startup, ignoring argc and argv. see openscad.cc for info

1. Command line and stdin/stdout

The Windows Command Line has a feature where a program must either be GUI or 
console, not both. A gui program cannot print/pipe to the cmdline and a 
cmdline program can't do GUI stuff. The 'type' of executable is set by a bit
within the file header.

The current OpenSCAD solution, as documented in winconsole.c, is the 'devenv'
solution. Two separate binaries are created, openscad.com for cmdline and
and openscad.exe for gui. The .com program is just a wrapper that pipes
the stdin/stdout to and from openscad.exe. The .com program is created during
the package build and bundled with the OpenSCAD binary packages for Windows(TM).

The .com file is only designed to be run from the Windows(TM) command line,
not from the GUI (as in a shortcut)

2. Command Line character display / rendering (glyphs) in console

The windows(TM) 'dos box' or 'cmd.exe' console is not typically able to 
display Unicode characters properly. To actually do that, one needs to 
set up the Font and Code Page used by the console program itself, and 
then rewrite output functions.

Currently OpenSCAD cannot properly output Unicode strings to the Windows 
console, even though it is properly processing unicode filenames 
and command line arguments. It can be confusing.

3. fstream and Unicode Filenames, UTF16, MingW, and FSF GNU libstdc++

Windows(TM) Filenames are encoded as UTF16, typically using wchar_t as 
the character type. The functions that allow writing to files in Windows 
require UTF16 filenames in wchar_t* strings. Numerous 'w' functions in 
Windows API provide for this, like _wfopen(), std::wstring, etc etc.

However there is no way (as of writing in early 2014) in MingW / Gnu 
libstdc++ to construct an c++ std::fstream (including ifstream/ofstream) 
with a UTF16 filename. In a few years, something called 'tr2' will come 
to MingW/Gnu libstdc++ and this problem will be solved. However, until 
that time, we, and many other Open Source programs, use workarounds.

OpenSCAD's PlatformUtils contains typedef of ofstream and ifstream to
'imingstream' and 'omingstream', which masquerade as of/ifstreams.
They are actually std::stringstreams, which means the entire file is
resident in memory during processing. see patches/mingstream for details.

4. Binary mode of file writing

Note that the issue of Filename encoding is completely separate from the
question of the encoding of the contents of the file itself. In OpenSCAD,
the .scad files should all be UTF8, the input formats like amf, xml, etc
should be UTF8, the ASCII formats like STL, DXF, OBJ, are all UTF8 because
ASCII is UTF8, etc etc. Also, all command line items are converted to UTF8
before any processing is done on them. Therefore. All file writing should
be in 'binary mode' on Windows and we write sequences of 8-bit bytes,
encoded in UTF8.

5. Boost and portability

Theoretically, Boost provides portable wrapper to some Windows and 
Unix/Mac file code, including fstream. In reality, Boost is only as portable
as the underlying libraries it is using. For the MingW cross-build case,
this means boost's filestreams won't work with Unicode filenames on Windows(TM).
This can lead to a lot of confusion when reading the boost documentation. 

Builds
======

1. MSVC

As of writing, (early 2014), MSVC has not been tested as a compiler
in several years is not known to work. The difficult part is compiling
the numerous dependency libraries. Libgmp for example, doesn't officially
support MSVC as a compiler. Additionally, the glib dependency has never 
been used under MSVC with OpenSCAD. Extensive work would be required to 
fix the build. 

2. MXE Cross build

The cross build, as detailed in README.md, is done from Linux and should
be relatively straightforward, if slow, on an ordinary Linux system like
Debian or Redhat. It can even be built on a Windows machine if one downloads
a Virtual Machine of linux and builds inside of the VM. 

The entire cross-build depends on the http://mxe.cc system, not on the 
packaged cross-build tools that come with standard linux distributions. 
MXE, in turn, uses the MingW project tools to link in various Windows operating
system functions.

3. MingW64 vs MingW32

MingW64 is not simply a 64 bit port of MingW32. It contains many 
improvements over MingW32 and works a little bit differently. Also, 
MingW64 can actually build both 64 bit and 32 bit binaries. However
MingW32 has been around longer and is theoretically in larger use.
MXE integrated MingW64 in 2013. 

As of writing (early 2014), OpenSCAD's build scripts use MingW32 for
the 32 bit builds and MingW64 for the 64-bit builds. As time goes on,
it may be possible to move to an entirely MingW64 system that builds both
types of binaries.

4. Test suite cross build

The test suite cannot currently run under windows, as of writing (Early 2014). 
However it can be run under the Wine environment under linux.

See tests/CMingw-cross-env.cmake and doc/testing.txt

